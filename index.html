<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Period Tracker</title>
    <link rel="manifest" href="/manifest.json" />
    <style>
      body {
        margin: 1vh 1vw;
        background-color: rgb(164, 198, 238);
      }
      ul,
      fieldset,
      legend {
        border: 1px solid;
        background-color: #fff;
      }
      ul {
        padding: 0;
        font-family: monospace;
      }
      li,
      legend {
        list-style-type: none;
        padding: 0.2em 0.5em;
        background-color: rgb(255, 230, 204);
      }
      li:nth-of-type(even) {
        background-color: inherit;
      }
    </style>
  </head>
  <body>
    <h1>Period tracker</h1>
    <form>
      <fieldset>
        <legend>Enter your period start and end date</legend>
        <p>
          <label for="start-date">Start date</label>
          <input type="date" id="start-date" required />
        </p>
        <p>
          <label for="end-date">End date</label>
          <input type="date" id="end-date" required />
        </p>
      </fieldset>
      <p>
        <button type="submit">Add Period</button>
      </p>
    </form>
    <button id="installButton">Install App</button>
         <button >Add </button>
    <section id="past-periods"></section>
    <script src="sw.js"></script>
    <script>
      const installButton = document.getElementById("installButton");

      let deferredPrompt;
      window.addEventListener("beforeinstallprompt", (event) => {
        console.log("hyyyy");
        // Prevent Chrome 76 and later from automatically showing the prompt
        event.preventDefault();
        // Stash the event so it can be triggered later.
        deferredPrompt = event;
        console.log("---------", deferredPrompt);
        // Show the install button
        document.getElementById("installButton").style.display = "block";
      });

      installButton.addEventListener("click", () => {
        console.log("click", deferredPrompt);
        if (deferredPrompt) {
          console.log("deferredPrompt", deferredPrompt);
          //log
          // Show the installation prompt
          deferredPrompt.prompt();
          // Wait for the user to respond to the prompt
          deferredPrompt.userChoice
            .then((choiceResult) => {
              if (choiceResult.outcome === "accepted") {
                console.log("User accepted the install prompt");
              } else {
                console.log("User dismissed the install prompt");
              }
              // Clear the deferredPrompt variable
              deferredPrompt = null;
              // Hide the install button
              installButton.style.display = "none";
            })
            .catch((error) => {
              console.error("Error while prompting to install:", error);
              // Clear the deferredPrompt variable
              deferredPrompt = null;
              // Hide the install button
              installButton.style.display = "none";
            });
        }
      });
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("sw.js").then(
          (registration) => {
            console.log(
              "Service worker registration successful:",
              registration
            );
          },
          (error) => {
            console.error(`Service worker registration failed: ${error}`);
          }
        );
      } else {
        console.error("Service workers are not supported.");
      }

      function renderPastPeriods() {
        // get the parsed string of periods, or an empty array.
        const periods = getAllStoredPeriods();

        // exit if there are no periods
        if (periods.length === 0) {
          return;
        }

        // Clear the list of past periods, since we're going to re-render it.
        pastPeriodContainer.innerHTML = "";

        const pastPeriodHeader = document.createElement("h2");
        pastPeriodHeader.textContent = "Past periods";

        const pastPeriodList = document.createElement("ul");

        // Loop over all periods and render them.
        periods.forEach((period) => {
          const periodEl = document.createElement("li");
          periodEl.textContent = `From ${formatDate(
            period.startDate
          )} to ${formatDate(period.endDate)}`;
          pastPeriodList.appendChild(periodEl);
        });

        pastPeriodContainer.appendChild(pastPeriodHeader);
        pastPeriodContainer.appendChild(pastPeriodList);
      }
      const newPeriodFormEl = document.getElementsByTagName("form")[0];
      const startDateInputEl = document.getElementById("start-date");
      const endDateInputEl = document.getElementById("end-date");
      const pastPeriodContainer = document.getElementById("past-periods");

      // Add the storage key as an app-wide constant
      const STORAGE_KEY = "period-tracker";

      // Listen to form submissions.
      newPeriodFormEl.addEventListener("submit", (event) => {
        event.preventDefault();
        const startDate = startDateInputEl.value;
        const endDate = endDateInputEl.value;
        if (checkDatesInvalid(startDate, endDate)) {
          return;
        }
        storeNewPeriod(startDate, endDate);
        renderPastPeriods();
        newPeriodFormEl.reset();
      });

      function checkDatesInvalid(startDate, endDate) {
        if (!startDate || !endDate || startDate > endDate) {
          newPeriodFormEl.reset();
          return true;
        }
        return false;
      }

      function storeNewPeriod(startDate, endDate) {
        const periods = getAllStoredPeriods();
        periods.push({ startDate, endDate });
        periods.sort((a, b) => {
          return new Date(b.startDate) - new Date(a.startDate);
        });
        window.localStorage.setItem(STORAGE_KEY, JSON.stringify(periods));
      }

      function getAllStoredPeriods() {
        const data = window.localStorage.getItem(STORAGE_KEY);
        const periods = data ? JSON.parse(data) : [];
        console.dir(periods);
        console.log(periods);
        return periods;
      }

      function renderPastPeriods() {
        const pastPeriodHeader = document.createElement("h2");
        const pastPeriodList = document.createElement("ul");
        const periods = getAllStoredPeriods();
        if (periods.length === 0) {
          return;
        }
        pastPeriodContainer.innerHTML = "";
        pastPeriodHeader.textContent = "Past periods";
        periods.forEach((period) => {
          const periodEl = document.createElement("li");
          periodEl.textContent = `From ${formatDate(
            period.startDate
          )} to ${formatDate(period.endDate)}`;
          pastPeriodList.appendChild(periodEl);
        });

        pastPeriodContainer.appendChild(pastPeriodHeader);
        pastPeriodContainer.appendChild(pastPeriodList);
      }

      function formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString("en-US", { timeZone: "UTC" });
      }

      function checkDatesInvalid(startDate, endDate) {
        // Check that end date is after start date and neither is null.
        console.log(
          !startDate,
          !endDate,
          startDate,
          endDate,
          startDate > endDate
        );
        if (!startDate || !endDate || startDate > endDate) {
          // To make the validation robust we could:
          // 1. add error messaging based on error type
          // 2. Alert assistive technology users about the error
          // 3. move focus to the error location
          // instead, for now, we clear the dates if either
          // or both are invalid
          newPeriodFormEl.reset();
          // as dates are invalid, we return true
          return true;
        }
        // else
        return false;
      }
      // create constants for the form and the form controls
      // const newPeriodFormEl = document.getElementsByTagName("form")[0];
      // const startDateInputEl = document.getElementById("start-date");
      // const endDateInputEl = document.getElementById("end-date");

      // Listen to form submissions.
      newPeriodFormEl.addEventListener("submit", (event) => {
        // Prevent the form from submitting to the server
        // since everything is client-side.
        event.preventDefault();

        // Get the start and end dates from the form.
        const startDate = startDateInputEl.value;
        const endDate = endDateInputEl.value;

        // Check if the dates are invalid
        if (checkDatesInvalid(startDate, endDate)) {
          // If the dates are invalid, exit.
          return;
        }

        // Store the new period in our client-side storage.
        storeNewPeriod(startDate, endDate);

        // Refresh the UI.
        renderPastPeriods();

        // Reset the form.
        newPeriodFormEl.reset();
      });
    </script>
  </body>
</html>
